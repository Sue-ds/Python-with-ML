{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "adb5fbba-4753-4a72-8584-24c96b381c35",
   "metadata": {},
   "source": [
    "# 1. Pythonic code\n",
    "## 1.1. Array, Split, Join"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "96e3eb1d-563a-4ab2-8a0d-c09affa4b5a8",
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "c40904a0-ffd5-497e-87c1-e7db866465a5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(3,)\n"
     ]
    }
   ],
   "source": [
    "c = np.array([1,2,3])\n",
    "print(c.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "a61f76d5-a568-4646-a76d-8834c11cfa33",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "c[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "51075ecc-dd1a-44d8-b71a-5c8819bd2a09",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1, 3)\n"
     ]
    }
   ],
   "source": [
    "r= np.array([[1,2,3]])\n",
    "print(r.shape)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "a4af2637-7a04-47b6-8b7a-047103b36551",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1, 2, 3]])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "r"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "abe2d38b-0475-47cb-8d5e-4fd143ffeca0",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[1 2 3]]\n"
     ]
    }
   ],
   "source": [
    "print(r)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "003cca92-693e-43d2-b2d9-ca416ccfed00",
   "metadata": {},
   "outputs": [],
   "source": [
    "A = np.array([[1,2], [2,3], [3,4]])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "c6ef7f65-4894-4b9a-aa7a-a63a5e69ac51",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1, 2],\n",
       "       [2, 3],\n",
       "       [3, 4]])"
      ]
     },
     "execution_count": 11,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "A"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "4ddefe64-9431-4cf8-bf7d-809631339ed1",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1, 2, 3],\n",
       "       [2, 3, 4]])"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# T : transpose\n",
    "A.T"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "e19000c8-89da-430e-9798-d200e12d846c",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[14, 20],\n",
       "       [20, 29]])"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# dot : 내적\n",
    "np.dot(A.T, A)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "721f5b70-7eea-443d-a04a-a98828e3baa9",
   "metadata": {},
   "source": [
    "**Split 함수** : String Type 의 값을 나눠서 리스트 형태로 변환"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "8c4f167e-0d2e-474f-885b-098d53ce4cf7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['zero', ' one', ' two', ' three']\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "'zero'"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "items = 'zero, one, two, three'\n",
    "print(items.split(','))\n",
    "\n",
    "# 리스트의 각 값을 변수로 unpacking\n",
    "a, b, c, d = items.split(',')\n",
    "a"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2ff9c134-d53e-4de7-82f6-50cd8ca9fb18",
   "metadata": {},
   "source": [
    "**Join 함수** : String List를 합쳐서 하나의 String 으로 다시 반환!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "4db3ac57-bd8d-4469-98ec-e9696eef94d0",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['zero', 'one', 'two', 'three']"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "numbers = items.split(', ')\n",
    "numbers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "8d59161e-0905-4c05-8263-fbbb0787f4f3",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "zeroonetwothree\n",
      "zero one two three\n",
      "zero,one,two,three\n"
     ]
    }
   ],
   "source": [
    "# 연결 시 공백 없음\n",
    "numbers_a = ''.join(numbers)\n",
    "print(numbers_a)\n",
    "\n",
    "# 연결 시 공백 포함\n",
    "numbers_b = ' '.join(numbers)\n",
    "print(numbers_b)\n",
    "\n",
    "# 연결 시 , 로 연결\n",
    "numbers_c = ','.join(numbers)\n",
    "print(numbers_c)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0b148e3c-e1ff-45c0-b86a-7a84ef0c5f44",
   "metadata": {},
   "source": [
    "`정리` : **Split:문자형(스트링)을 리스트로 변환 Join:리스트를 다시 문자형(스트링)으로 변환**"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0b1fd240-11ba-4670-81ec-f853a4a78fc3",
   "metadata": {},
   "source": [
    "## 1.2. List Comprehension"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b66bdced-ad4f-4c93-bc52-e680d6aaae40",
   "metadata": {},
   "source": [
    "파이썬에서 가장 많이 사용되는 기법 중에 하나 : 리스트 안에 리스트\n",
    "* List Comprehension\n",
    "* Nested For loop"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "727e6831-db2e-4f0b-bddc-e80edc0703cf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
      "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n",
      "[0, 2, 4, 6, 8]\n"
     ]
    }
   ],
   "source": [
    "# for loop + append 사용하기\n",
    "\n",
    "# 리스트 타입 형성\n",
    "result = []\n",
    "for i in range(10):\n",
    "    result.append(i)\n",
    "\n",
    "print(result)\n",
    "\n",
    "# List Comprehension 을 사용해서 List 안에 리스트를 만들수도 있음\n",
    "result_a = [i for i in range(10)]\n",
    "print(result_a)\n",
    "\n",
    "result_b = [i for i in range(10) if i % 2 == 0]\n",
    "print(result_b)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "bb197198-07f9-4bfa-8c3c-25f74fa6ccbb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['SE', 'St', 'Sh', 'Sa', 'Sn', 'UE', 'Ut', 'Uh', 'Ua', 'Un', 'EE', 'Et', 'Eh', 'Ea', 'En']\n",
      "['SE', 'St', 'Sh', 'Sa', 'Sn', 'UE', 'Ut', 'Uh', 'Ua', 'Un', 'EE', 'Et', 'Eh', 'Ea', 'En']\n"
     ]
    }
   ],
   "source": [
    "word1 = 'SUE'\n",
    "word2 = 'Ethan'\n",
    "result_c = [i+j for i in word1 for j in word2]\n",
    "print(result_c)\n",
    "\n",
    "result_d = []\n",
    "for i in word1:\n",
    "    for j in word2:\n",
    "        result_d.append(i+j)\n",
    "print(result_d)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "id": "0cf27049-6799-481b-a663-3ffb751e8ea5",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['EE']"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# List Comprehension 에 필터 추가하기\n",
    "\n",
    "result_e = [i+j for i in word1 for j in word2 if(i==j)]\n",
    "result_e"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "04b88066-0bce-4ce0-a508-2e6dd0940dfd",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['Markdown', 'for', 'Jupyter', 'notebooks', 'cheatsheet']\n",
      "['MARKDOWN', 'markdown', 8]\n",
      "['FOR', 'for', 3]\n",
      "['JUPYTER', 'jupyter', 7]\n",
      "['NOTEBOOKS', 'notebooks', 9]\n",
      "['CHEATSHEET', 'cheatsheet', 10]\n"
     ]
    }
   ],
   "source": [
    "# List를 튜플 형태로도 만들 수 있음\n",
    "\n",
    "word3 = 'Markdown for Jupyter notebooks cheatsheet'.split()\n",
    "print(word3)\n",
    "\n",
    "result_f = [[i.upper(), i.lower(), len(i)]for i in word3]\n",
    "for w in result_f:\n",
    "    print(w)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "id": "5c4473c8-5a7b-455a-80b4-d8e465a19a58",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['AD', 'AE', 'AF', 'BD', 'BE', 'BF', 'CD', 'CE', 'CF']\n",
      "[['AD', 'BD', 'CD'], ['AE', 'BE', 'CE'], ['AF', 'BF', 'CF']]\n"
     ]
    }
   ],
   "source": [
    "# List comprehension 을 통해서 dimension 을 조정할 수도 있음\n",
    "\n",
    "case_1 = ['A', 'B', 'C']\n",
    "case_2 = ['D', 'E', 'F']\n",
    "\n",
    "result_g = [i+j for i in case_1 for j in case_2]\n",
    "print(result_g)\n",
    "\n",
    "\n",
    "# [[]]의 바깥에 있는 for j in case_2 가 먼저 고정됨 - D E F 고정 후 출력됨 (중요)\n",
    "result_h = [[i+j for i in case_1] for j in case_2]\n",
    "print(result_h)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bcd4946a-ef3c-4344-96ff-e0a098f10ff1",
   "metadata": {},
   "source": [
    "## 1.3. Enumerate & Zip\n",
    "\n",
    "`enumerate` : 리스트의 값을 추출할때 함께 인덱스를 추출할 수 있는 방법\n",
    "<br>\n",
    "`zip` : 두개 이상의 list 값을 병렬적으로 추출할 수 있는 모듈"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "b2c6a337-29a2-4d60-8ebc-8e5e0d51f7c2",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 tic\n",
      "1 tac\n",
      "2 toc\n"
     ]
    }
   ],
   "source": [
    "# 리스트에서 값을 추출할 때 그 인덱스를 같이 추출하는 법! \n",
    "\n",
    "for i, v in enumerate(['tic', 'tac', 'toc']):\n",
    "    print(i, v)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "1690dc55-5e92-406a-8fa8-e7425e104d7e",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[(0, 'sue'), (1, 'ethan')]"
      ]
     },
     "execution_count": 53,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "list_love = ['sue', 'ethan']\n",
    "\n",
    "# 리스트 안에 있는 인덱스와 밸류를 언패킹하여 리스트로 따로 저장할 수도 있음 :)\n",
    "list(enumerate(list_love))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 59,
   "id": "58399b4c-cf19-44f1-9264-a61415042b6f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{0: 'You',\n",
       " 1: 'can',\n",
       " 2: 'use',\n",
       " 3: 'Markdown',\n",
       " 4: 'to',\n",
       " 5: 'format',\n",
       " 6: 'documentation',\n",
       " 7: 'you',\n",
       " 8: 'add',\n",
       " 9: 'to',\n",
       " 10: 'Markdown',\n",
       " 11: 'cells',\n",
       " 12: 'in',\n",
       " 13: 'your',\n",
       " 14: 'Jupyter',\n",
       " 15: 'notebook.'}"
      ]
     },
     "execution_count": 59,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Enumerate는 문장에서 단어의 순서를 매길 때에도 유용하게 쓰일 수 있음! (딕셔너리📋 타입으로 저장, 텍스트 마이닝을 할 때 활용 많이 됩니다)\n",
    "\n",
    "{i:j for i, j in enumerate('You can use Markdown to format documentation you add to Markdown cells in your Jupyter notebook.'.split())}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "id": "f2aa291c-90e4-4ced-b27a-8b58a02f089f",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "a1 b1\n",
      "a2 b2\n",
      "a3 b3\n",
      "(1, 10, 100) (2, 20, 200) (3, 30, 300)\n",
      "[6, 60, 600]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[111, 222, 333]"
      ]
     },
     "execution_count": 65,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# zip : 두 개의 리스트 값을 병렬적으로 추출\n",
    "\n",
    "alist = ['a1', 'a2', 'a3']\n",
    "blist = ['b1','b2', 'b3']\n",
    "\n",
    "for a, b in zip(alist, blist):\n",
    "    print(a, b)\n",
    "\n",
    "\n",
    "# 각 튜플의 인덱스가 같은 값끼리 묶도록 디자인되어 있음\n",
    "a,b,c = zip((1,2,3),(10,20,30),(100,200,300))\n",
    "print(a,b,c)\n",
    "\n",
    "# List comprehension 이랑 같이 쓰이면 더 효과적일 때가 많음 \n",
    "print([sum(x) for x in zip((1,10,100), (2,20,200), (3,30,300))])\n",
    "[sum(y) for y in zip((1,2,3),(10,20,30),(100,200,300))]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "id": "58009fc8-c6e0-4c9c-b2b3-30f3e4957328",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0 ('a1', 'b1')\n",
      "1 ('a2', 'b2')\n",
      "2 ('a3', 'b3')\n"
     ]
    }
   ],
   "source": [
    "# for loop 를 활용해서 인덱스 번호를 매겨서 매칭도 가능함\n",
    "\n",
    "alist = ['a1', 'a2', 'a3']\n",
    "blist = ['b1','b2', 'b3']\n",
    "\n",
    "for i,(a,b) in enumerate(zip(alist, blist)):\n",
    "    print(i,(a,b))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e4a8f503-602b-4041-9738-42d2fe0c60aa",
   "metadata": {},
   "source": [
    "## 1.4. Lambda & MapReduce\n",
    "* Lambda : 함수처럼 사용가능한 익명함수, 수학의 람다 대수에서 유래함"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "id": "fb266bff-3739-4203-9ae6-3486332100aa",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "3\n",
      "3\n"
     ]
    }
   ],
   "source": [
    "def f(x,y):\n",
    "    return x+y\n",
    "print(f(1,2))\n",
    "\n",
    "f= lambda x,y : x+y\n",
    "print(f(1,2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "id": "11b76b9f-faa7-4c63-a7d6-f1a34bcdb9b5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "9\n",
      "1.5\n",
      "6\n"
     ]
    }
   ],
   "source": [
    "# 판다스에서는 람다함수를 쓸 일이 꽤 많음\n",
    "f = lambda x: x ** 2\n",
    "print(f(3))\n",
    "\n",
    "f = lambda x: x / 2\n",
    "print(f(3))\n",
    "\n",
    "# 굳이 f 를 지정하지 않아도 가능\n",
    "print((lambda x: x + 1)(5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "id": "1f1854b5-e268-4bee-a685-02f0efb3fbe8",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1, 4, 9, 16, 25]\n",
      "[2, 4, 6, 8, 10]\n",
      "[1, 4, 3, 16, 5]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[1, 4, 9, 16, 25]"
      ]
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Map & Reduce : 시퀀스형 자료형에서 각 요소에 동일한 기능을 적용시킴\n",
    "\n",
    "ex_1 = [1,2,3,4,5]\n",
    "f = lambda x: x**2\n",
    "print(list(map(f,ex_1)))\n",
    "\n",
    "# map 만 쓰게 되면 저장된 메모리 주소만 나옴! 무조건 list랑 같이 써야 함\n",
    "\n",
    "ex_2 = [1, 2, 3, 4, 5]\n",
    "f = lambda x, y: x + y\n",
    "print(list(map(f, ex_2, ex_2)))\n",
    "\n",
    "print(list(map(\n",
    "    lambda x: x ** 2 if x % 2 == 0 else x,\n",
    "    ex_1)))\n",
    "\n",
    "# Map&Reduce 도 많이 쓰이긴 하는데 List Comprehension 이 짱 편함\n",
    "[i **2 for i in ex_1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 92,
   "id": "f143c198-ee55-49c3-9257-6ca24f44e417",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "15\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "120"
      ]
     },
     "execution_count": 92,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "# Reduce, factorial 각각의 element를 하나씩 붙여가며 쓰는 것!\n",
    "from functools import reduce\n",
    "print(reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]))\n",
    "\n",
    "def factorial(n):\n",
    "    return reduce(\n",
    "            lambda x, y: x*y, range(1, n+1))\n",
    "factorial(5)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9208a78e-be97-41ff-bb27-69ba50f0aae8",
   "metadata": {},
   "source": [
    "## 1.5. Asterisk"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "id": "e406f439-c06e-495a-b1bc-9f4c8e3828de",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 (2, 3, 4, 5, 6)\n",
      "<class 'tuple'>\n",
      "1 {'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}\n",
      "<class 'dict'>\n"
     ]
    }
   ],
   "source": [
    "# 단순 곱셈, 제곱연산, 가변인자 활용 등 여러 부분에서 다양하게 사용 : Asterisk(*)\n",
    "\n",
    "# args : 값을 한꺼번에 받아라\n",
    "# 나머지가 한꺼번에 튜플 형태로 들어감\n",
    "def asterisk_test1(a, *args):\n",
    "    print(a, args)\n",
    "    print(type(args))\n",
    "    \n",
    "asterisk_test1(1,2,3,4,5,6)\n",
    "\n",
    "# args : 값을 한꺼번에 받아라\n",
    "# 나머지가 한꺼번에 딕셔너리 형태로 들어감\n",
    "def asterisk_test2(a, **kargs):\n",
    "    print(a, kargs)\n",
    "    print(type(kargs))\n",
    "\n",
    "asterisk_test2(1, b=2, c=3, d=4, e=5, f=6)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "id": "567969da-326f-49ac-89a7-c5e8e5144e66",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1 2 3 4 5 6\n",
      "<class 'tuple'>\n"
     ]
    }
   ],
   "source": [
    "# unpacking a container\n",
    "\n",
    "def asterisk_test3(a, args):\n",
    "    print(a, *args)\n",
    "    print(type(args))\n",
    "\n",
    "asterisk_test3(1, (2,3,4,5,6))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 105,
   "id": "e490721d-180a-40e7-8c12-3194065b5129",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1, 2] [3, 4] [5, 6]\n",
      "[1, 2] [3, 4] [5, 6]\n",
      "([1, 2], [3, 4], [5, 6])\n"
     ]
    }
   ],
   "source": [
    "a, b, c = ([1, 2], [3, 4], [5, 6])\n",
    "print(a, b, c)\n",
    "\n",
    "data = ([1, 2], [3, 4], [5, 6])\n",
    "print(*data)\n",
    "print(data)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "id": "775b413f-a871-40b2-a951-e285203253d6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(1, 3, 5)\n",
      "9\n",
      "(2, 4, 6)\n",
      "12\n"
     ]
    }
   ],
   "source": [
    "# zip 은 해당 인덱스별로 정렬, 언패킹한 다음에 해당 인덱스 정렬\n",
    "\n",
    "for data in zip(*([1, 2], [3, 4], [5, 6])):\n",
    "    print(data)\n",
    "    print(sum(data))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 113,
   "id": "b8de6812-11b7-4f1f-b0c6-25efbbb7c5f5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "10 3 2 1 56\n"
     ]
    }
   ],
   "source": [
    "# ** 는 딕셔너리 타입의 데이터를 풀어줌\n",
    "def asterisk_test4(a, b, c, d, e=0):\n",
    "    print(a, b, c, d, e)\n",
    "\n",
    "data = {\"d\":1 , \"c\":2, \"b\":3, \"e\":56}\n",
    "asterisk_test4(10, **data)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a6264e7-37b9-403e-9b89-8cbbe6c001f9",
   "metadata": {},
   "source": [
    "## 1.6. Data structure and collection\n",
    "* 자료 구조에 대한 기본적인 이해 : 대학교 2학년 수준에서 배우는!\n",
    "* que, order 등"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "8ff4ebf3-c411-4afa-b578-8cfd5f253426",
   "metadata": {},
   "source": [
    "**deque** : Stack 과 Queue 지원하는 모듈로 리스트에 비해서 자료 저장 방식이 효율적\n",
    "* 파이썬 내장 모듈에서는 따로 스택 라이브러리가 존재하지 않고, deque 라이브러리를 import 해서 스택 대신 사용\n",
    "\n",
    "**from collections import deque**\n",
    "- dq=deque() # 덱 생성\n",
    "- dq.append() # 덱의 가장 오른쪽에 원소 삽입\n",
    "- dq.popleft() # 가장 왼쪽 원소 반환\n",
    "- dq.appendleft() # 덱의 가장 왼쪽에 원소 삽입\n",
    "- dp.pop() # 가장 오른쪽 원소 반환\n",
    "- dp.clear() # 모든 원소 제거\n",
    "- dp.copy() # 덱 복사\n",
    "- dp.count(x) #x와 같은 원소의 개수를 계산\n",
    "\n",
    "<br/>\n",
    "* stack 과 unstack : groupby 로 구할 때 unstack()이라는 기능을 사용하여 아래와 같이 컬럼에 인덱스 값을 올려서 표기할 수 있음\n",
    "\n",
    "``df[df[\"Year\"] > 2010].groupby([\"Year\", \"Country\"])[\"Life_Expectancy\"].mean().unstack()``"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 119,
   "id": "97ffb00e-6d32-443a-8246-2b032365d098",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "deque([0, 1, 2, 3, 4])\n",
      "deque([10, 0, 1, 2, 3, 4])\n"
     ]
    }
   ],
   "source": [
    "# deque 는 굉장히 유용함. 특히 rotate queue 에서 잘 쓰임\n",
    "\n",
    "from collections import deque\n",
    "\n",
    "deque_list = deque()\n",
    "for i in range(5):\n",
    "    deque_list.append(i)\n",
    "print(deque_list)\n",
    "\n",
    "deque_list.appendleft(10)\n",
    "print(deque_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 121,
   "id": "1b864122-af4e-4425-992f-22b8954e9605",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "deque([3, 4, 10, 0, 1, 2])\n",
      "deque([2, 1, 0, 10, 4, 3])\n"
     ]
    }
   ],
   "source": [
    "# rotate 하면서 queue!\n",
    "\n",
    "deque_list.rotate(2)\n",
    "print(deque_list)\n",
    "\n",
    "print(deque(reversed(deque_list)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 123,
   "id": "6993d676-1110-498d-8c49-93a63bfa32f7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "deque([3, 4, 10, 0, 1, 2, 5, 6, 7])\n",
      "deque([7, 6, 5, 3, 4, 10, 0, 1, 2, 5, 6, 7])\n"
     ]
    }
   ],
   "source": [
    "deque_list.extend([5, 6, 7])\n",
    "print(deque_list)\n",
    "\n",
    "deque_list.extendleft([5, 6, 7])\n",
    "print(deque_list)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 125,
   "id": "a50e939d-8abf-4faf-bb4e-e612e8470e28",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "x 100\n",
      "y 200\n",
      "z 300\n",
      "l 500\n",
      "x 100\n",
      "y 200\n",
      "z 300\n",
      "l 500\n"
     ]
    }
   ],
   "source": [
    "# OrderedDict : Dict 와는 다르게 데이터를 입력한 순서대로 반환해줌!\n",
    "from collections import OrderedDict\n",
    "\n",
    "d = {}\n",
    "d['x'] = 100\n",
    "d['y'] = 200\n",
    "d['z'] = 300\n",
    "d['l'] = 500\n",
    "\n",
    "for k, v in d.items():\n",
    "    print(k, v)\n",
    "\n",
    "\n",
    "d = OrderedDict()\n",
    "d['x'] = 100\n",
    "d['y'] = 200\n",
    "d['z'] = 300\n",
    "d['l'] = 500\n",
    "\n",
    "for k, v in d.items():\n",
    "    print(k, v)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 129,
   "id": "c0ee05f4-4dec-443e-a933-98fe508e2cbc",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "l 500\n",
      "x 100\n",
      "y 200\n",
      "z 300\n",
      "l 500\n",
      "z 300\n",
      "y 200\n",
      "x 100\n"
     ]
    }
   ],
   "source": [
    "# 딕트를 밸류/키로 정렬할 때 상당히 성가신데 유용하게 쓸 수 있음\n",
    "for k, v in OrderedDict(sorted(d.items(), key=lambda t: t[0])).items():\n",
    "    print(k, v)\n",
    "# lambda t: t[0]은 각 (키, 값) 쌍 t에서 키(t[0])를 반환하는 간단한 함수\n",
    "\n",
    "for k, v in OrderedDict(sorted(d.items(),\n",
    "                        reverse=True, key=lambda t: t[1])).items():\n",
    "    print(k, v)\n",
    "\n",
    "# 코드 해석: t[1]이 의미하는 것 : t[1]은 딕셔너리 d의 각 (키, 값) 쌍에서 값(value)을 가리킵니다.\n",
    "\n",
    "# 자세한 설명\n",
    "# t: sorted(d.items(), ...) 함수에서 반환되는 각각의 (키, 값) 쌍을 나타내는 임시 변수입니다. 즉, t는 두 개의 요소를 가진 튜플입니다.\n",
    "# t[0]: 튜플 t의 첫 번째 요소, 즉 키(key)를 의미합니다.\n",
    "# t[1]: 튜플 t의 두 번째 요소, 즉 값(value)을 의미합니다.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 135,
   "id": "d1ce8bcc-548a-4a8f-8c34-6ea6d0cc2cc6",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0\n"
     ]
    }
   ],
   "source": [
    "# 교수님은 일반적으로 딕셔너리를 쓸 때 디폴트딕트를 쓰는 경우가 더 많으심\n",
    "\n",
    "from collections import defaultdict\n",
    "from collections import OrderedDict\n",
    "\n",
    "# d = dict()\n",
    "# print(d[\"first\"])      # 아무것도 설정되어 있지 않기 때문에 이 경우에는 Key Error 가 발생함\n",
    "\n",
    "# Reference from\n",
    "d = defaultdict(object)     # Default dictionary를 생성\n",
    "d = defaultdict(lambda: 0)  # Default 값을 0으로 설정합\n",
    "print(d[\"first\"])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 139,
   "id": "2110257f-57af-486b-b573-2a0895e11726",
   "metadata": {},
   "outputs": [],
   "source": [
    "# 디폴트딕트는 글자 수를 셀 때 편함!\n",
    "\n",
    "text = \"\"\"A press release is the quickest and easiest way to get free publicity. If well written, a press release can result in multiple published articles about your firm and its products. And that can mean new prospects contacting you asking you to sell to them. Talk about low-hanging fruit!\n",
    "What's more, press releases are cost effective. If the release results in an article that (for instance) appears to recommend your firm or your product, that article is more likely to drive prospects to contact you than a comparable paid advertisement.\n",
    "However, most press releases never accomplish that. Most press releases are just spray and pray. Nobody reads them, least of all the reporters and editors for whom they're intended. Worst case, a badly-written press release simply makes your firm look clueless and stupid.\n",
    "For example, a while back I received a press release containing the following sentence: \"Release 6.0 doubles the level of functionality available, providing organizations of all sizes with a fast-to-deploy, highly robust, and easy-to-use solution to better acquire, retain, and serve customers.\"\n",
    "Translation: \"The new release does more stuff.\" Why the extra verbiage? As I explained in the post \"Why Marketers Speak Biz Blab\", the BS words are simply a way to try to make something unimportant seem important. And, let's face it, a 6.0 release of a product probably isn't all that important.\n",
    "As a reporter, my immediate response to that press release was that it's not important because it expended an entire sentence saying absolutely nothing. And I assumed (probably rightly) that the company's marketing team was a bunch of idiots.\"\"\".lower().split()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "id": "f9c98696-853b-4361-9074-8615016b0ad4",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'a': 12, 'press': 8, 'release': 8, 'is': 2, 'the': 9, 'quickest': 1, 'and': 9, 'easiest': 1, 'way': 2, 'to': 10, 'get': 1, 'free': 1, 'publicity.': 1, 'if': 2, 'well': 1, 'written,': 1, 'can': 2, 'result': 1, 'in': 3, 'multiple': 1, 'published': 1, 'articles': 1, 'about': 2, 'your': 4, 'firm': 3, 'its': 1, 'products.': 1, 'that': 7, 'mean': 1, 'new': 2, 'prospects': 2, 'contacting': 1, 'you': 3, 'asking': 1, 'sell': 1, 'them.': 1, 'talk': 1, 'low-hanging': 1, 'fruit!': 1, \"what's\": 1, 'more,': 1, 'releases': 3, 'are': 3, 'cost': 1, 'effective.': 1, 'results': 1, 'an': 2, 'article': 2, '(for': 1, 'instance)': 1, 'appears': 1, 'recommend': 1, 'or': 1, 'product,': 1, 'more': 2, 'likely': 1, 'drive': 1, 'contact': 1, 'than': 1, 'comparable': 1, 'paid': 1, 'advertisement.': 1, 'however,': 1, 'most': 2, 'never': 1, 'accomplish': 1, 'that.': 1, 'just': 1, 'spray': 1, 'pray.': 1, 'nobody': 1, 'reads': 1, 'them,': 1, 'least': 1, 'of': 5, 'all': 3, 'reporters': 1, 'editors': 1, 'for': 2, 'whom': 1, \"they're\": 1, 'intended.': 1, 'worst': 1, 'case,': 1, 'badly-written': 1, 'simply': 2, 'makes': 1, 'look': 1, 'clueless': 1, 'stupid.': 1, 'example,': 1, 'while': 1, 'back': 1, 'i': 3, 'received': 1, 'containing': 1, 'following': 1, 'sentence:': 1, '\"release': 1, '6.0': 2, 'doubles': 1, 'level': 1, 'functionality': 1, 'available,': 1, 'providing': 1, 'organizations': 1, 'sizes': 1, 'with': 1, 'fast-to-deploy,': 1, 'highly': 1, 'robust,': 1, 'easy-to-use': 1, 'solution': 1, 'better': 1, 'acquire,': 1, 'retain,': 1, 'serve': 1, 'customers.\"': 1, 'translation:': 1, '\"the': 1, 'does': 1, 'stuff.\"': 1, 'why': 1, 'extra': 1, 'verbiage?': 1, 'as': 2, 'explained': 1, 'post': 1, '\"why': 1, 'marketers': 1, 'speak': 1, 'biz': 1, 'blab\",': 1, 'bs': 1, 'words': 1, 'try': 1, 'make': 1, 'something': 1, 'unimportant': 1, 'seem': 1, 'important.': 2, 'and,': 1, \"let's\": 1, 'face': 1, 'it,': 1, 'product': 1, 'probably': 1, \"isn't\": 1, 'reporter,': 1, 'my': 1, 'immediate': 1, 'response': 1, 'was': 2, \"it's\": 1, 'not': 1, 'important': 1, 'because': 1, 'it': 1, 'expended': 1, 'entire': 1, 'sentence': 1, 'saying': 1, 'absolutely': 1, 'nothing.': 1, 'assumed': 1, '(probably': 1, 'rightly)': 1, \"company's\": 1, 'marketing': 1, 'team': 1, 'bunch': 1, 'idiots.': 1}\n",
      "a 12\n",
      "to 10\n",
      "the 9\n",
      "and 9\n",
      "press 8\n",
      "release 8\n",
      "that 7\n",
      "of 5\n",
      "your 4\n",
      "in 3\n",
      "firm 3\n",
      "you 3\n",
      "releases 3\n",
      "are 3\n",
      "all 3\n",
      "i 3\n",
      "is 2\n",
      "way 2\n",
      "if 2\n",
      "can 2\n",
      "about 2\n",
      "new 2\n",
      "prospects 2\n",
      "an 2\n",
      "article 2\n",
      "more 2\n",
      "most 2\n",
      "for 2\n",
      "simply 2\n",
      "6.0 2\n",
      "as 2\n",
      "important. 2\n",
      "was 2\n",
      "quickest 1\n",
      "easiest 1\n",
      "get 1\n",
      "free 1\n",
      "publicity. 1\n",
      "well 1\n",
      "written, 1\n",
      "result 1\n",
      "multiple 1\n",
      "published 1\n",
      "articles 1\n",
      "its 1\n",
      "products. 1\n",
      "mean 1\n",
      "contacting 1\n",
      "asking 1\n",
      "sell 1\n",
      "them. 1\n",
      "talk 1\n",
      "low-hanging 1\n",
      "fruit! 1\n",
      "what's 1\n",
      "more, 1\n",
      "cost 1\n",
      "effective. 1\n",
      "results 1\n",
      "(for 1\n",
      "instance) 1\n",
      "appears 1\n",
      "recommend 1\n",
      "or 1\n",
      "product, 1\n",
      "likely 1\n",
      "drive 1\n",
      "contact 1\n",
      "than 1\n",
      "comparable 1\n",
      "paid 1\n",
      "advertisement. 1\n",
      "however, 1\n",
      "never 1\n",
      "accomplish 1\n",
      "that. 1\n",
      "just 1\n",
      "spray 1\n",
      "pray. 1\n",
      "nobody 1\n",
      "reads 1\n",
      "them, 1\n",
      "least 1\n",
      "reporters 1\n",
      "editors 1\n",
      "whom 1\n",
      "they're 1\n",
      "intended. 1\n",
      "worst 1\n",
      "case, 1\n",
      "badly-written 1\n",
      "makes 1\n",
      "look 1\n",
      "clueless 1\n",
      "stupid. 1\n",
      "example, 1\n",
      "while 1\n",
      "back 1\n",
      "received 1\n",
      "containing 1\n",
      "following 1\n",
      "sentence: 1\n",
      "\"release 1\n",
      "doubles 1\n",
      "level 1\n",
      "functionality 1\n",
      "available, 1\n",
      "providing 1\n",
      "organizations 1\n",
      "sizes 1\n",
      "with 1\n",
      "fast-to-deploy, 1\n",
      "highly 1\n",
      "robust, 1\n",
      "easy-to-use 1\n",
      "solution 1\n",
      "better 1\n",
      "acquire, 1\n",
      "retain, 1\n",
      "serve 1\n",
      "customers.\" 1\n",
      "translation: 1\n",
      "\"the 1\n",
      "does 1\n",
      "stuff.\" 1\n",
      "why 1\n",
      "extra 1\n",
      "verbiage? 1\n",
      "explained 1\n",
      "post 1\n",
      "\"why 1\n",
      "marketers 1\n",
      "speak 1\n",
      "biz 1\n",
      "blab\", 1\n",
      "bs 1\n",
      "words 1\n",
      "try 1\n",
      "make 1\n",
      "something 1\n",
      "unimportant 1\n",
      "seem 1\n",
      "and, 1\n",
      "let's 1\n",
      "face 1\n",
      "it, 1\n",
      "product 1\n",
      "probably 1\n",
      "isn't 1\n",
      "reporter, 1\n",
      "my 1\n",
      "immediate 1\n",
      "response 1\n",
      "it's 1\n",
      "not 1\n",
      "important 1\n",
      "because 1\n",
      "it 1\n",
      "expended 1\n",
      "entire 1\n",
      "sentence 1\n",
      "saying 1\n",
      "absolutely 1\n",
      "nothing. 1\n",
      "assumed 1\n",
      "(probably 1\n",
      "rightly) 1\n",
      "company's 1\n",
      "marketing 1\n",
      "team 1\n",
      "bunch 1\n",
      "idiots. 1\n"
     ]
    }
   ],
   "source": [
    "word_count = {}\n",
    "for word in text:\n",
    "    if word in word_count.keys():\n",
    "        word_count[word] += 1\n",
    "    else:\n",
    "        word_count[word] = 1\n",
    "print(word_count)\n",
    "\n",
    "word_count = defaultdict(object)     # Default dictionary를 생성\n",
    "word_count = defaultdict(lambda: 0)  # Default 값을 0으로 설정합\n",
    "for word in text:\n",
    "    word_count[word] += 1\n",
    "for i, v in OrderedDict(sorted(\n",
    "        word_count.items(), key=lambda t: t[1], reverse=True)).items():\n",
    "    print(i, v)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "id": "6cecded4-c048-4640-b787-bfaf55e3e7cb",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Counter({'e': 2, 'S': 1, 'u': 1, 't': 1, 'h': 1, 'a': 1, 'n': 1})\n"
     ]
    }
   ],
   "source": [
    "# 텍스트를 핸들링할 때 : counter 모듈을 활용해서 딕셔너리 타입으로 변환\n",
    "\n",
    "from collections import Counter\n",
    "c = Counter()\n",
    "c = Counter(\"Sueethan\")\n",
    "print(c)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
